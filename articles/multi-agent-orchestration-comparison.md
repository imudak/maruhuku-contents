---
title: "マルチエージェントAI開発の現実 — multi-agent-shogun vs 統合プラットフォーム実践比較"
emoji: "⚔️"
type: "tech"
topics: ["Claude", "AI", "マルチエージェント", "自動化", "開発効率"]
published: false
---

## はじめに

「AIエージェントを複数並列で動かせば開発が爆速になるのでは」と考えて、マルチエージェントオーケストレーションシステム [multi-agent-shogun](https://github.com/yohey-w/multi-agent-shogun) を導入しました。

tmux上で複数のClaude Codeインスタンスを戦国時代の軍制で管理するという、ユニークなOSSです。forkして自分の環境に合わせた設定を入れ、さあ本格運用——と思った矢先、Claude Code本体にオーケストレーション機能が追加されました。

結果、導入から2週間で統合プラットフォーム（OpenClaw）側に一本化しています。ただ、この短い期間の比較で見えてきたものがあったので共有します。

:::message
[前回の記事](https://zenn.dev/imudak/articles/ai-autonomous-dev-practice)では「司令塔AI + マルチエージェント」の概要を紹介しました。今回はオーケストレーション層にフォーカスします。

multi-agent-shogunの設計・実装は[yohey-w氏](https://github.com/yohey-w)によるものです。自分はfork・設定・運用した立場から比較しています。
:::

## 比較対象

### A. multi-agent-shogun（tmux + YAMLキュー方式）

[yohey-w氏が開発したOSS](https://github.com/yohey-w/multi-agent-shogun)で、tmux上で複数のClaude Codeインスタンスを戦国時代の軍制で管理します。

```
        殿（人間）
           │
           ▼
    ┌──────────────┐
    │  将軍(SHOGUN) │  ← Claude Code #1: 統括・戦略
    └──────┬───────┘
           │ YAMLファイル + tmux send-keys
    ┌──────▼───────┐
    │  家老(KARO)   │  ← Claude Code #2: タスク分解・管理
    └──────┬───────┘
           │
  ┌─┬─┬─┬─┴─┬─┬─┬─┐
  │1│2│3│4│5│6│7│8│  ← Claude Code #3〜10: 実行部隊
  └─┴─┴─┴─┴─┴─┴─┴─┘
       足軽(ASHIGARU)
```

起動はbashスクリプトでtmuxセッション作成 → 9ペイン展開 → 全インスタンスにClaude Code起動 → 各自の指示書を読み込ませる、という流れです。

### B. 現行フロー（統合プラットフォーム方式）

OpenClaw上の司令塔AI（メインセッション）が、`sessions_spawn`やClaude Code CLIを必要に応じて起動する方式です。

```
        殿（人間）
           │
           ▼
    ┌──────────────┐
    │  司令塔AI     │  ← OpenClawメインセッション
    └──────┬───────┘
           │ sessions_spawn / claude -p
     ┌─────┼─────┐
     ▼     ▼     ▼
   [調査] [実装] [分析]  ← 必要時のみ起動、完了後消滅
```

## multi-agent-shogunの設計から読み取れる知見

shogunの設計には、マルチエージェント開発で直面する問題への対処が随所に埋め込まれています。運用してみて、その意図が理解できた部分を紹介します。

### 1. tmux send-keysの罠

shogunの指示書で最も強調されていたのが、エージェント間通信の制約です。

```bash
# ❌ これが動かない
tmux send-keys -t multiagent:0.0 'タスクを実行せよ' Enter

# ✅ 2回に分けないとEnterが正しく解釈されない
tmux send-keys -t multiagent:0.0 'タスクを実行せよ'
tmux send-keys -t multiagent:0.0 Enter
```

たった1行のコマンドが動きません。tmuxのキー送信タイミングとClaude Codeの入力バッファの相性問題です。shogunの指示書には「**絶対禁止パターン**」「**2回に分けろ**」と明記されており、この制約を発見した開発者の苦労が伺えます。

統合プラットフォームではAPI経由で通信するため、この問題は存在しません。

### 2. 「待機できない」問題

Claude Codeは対話型AIです。プロンプトが表示されている状態は「待機中」ではなく「停止中」です。

```
❌ 家老が足軽にタスクを振って「報告を待つ」
  → 家老のClaude Codeは停止。足軽がsend-keysしても処理できない

✅ 「起こされたら全確認」方式
  → 足軽がsend-keysで起こす → 家老が全報告ファイルをスキャン → 次のアクション
```

Claude Codeをマルチエージェントで使う上での根本的な制約です。ポーリング（定期確認ループ）はAPI代金の浪費になるため禁止。非同期イベント駆動にせざるを得ません。

統合プラットフォームではheartbeat機能とcronジョブで自然に解決できます。待機コストはゼロです。

### 3. レースコンディション対策

8つの足軽が並列で動くと、ファイル競合が発生します。

```
❌ 足軽1 → output.md に書き込み中
   足軽2 → output.md に書き込み → 上書き！

✅ 各自専用ファイルに分離
   足軽1 → output_1.md
   足軽2 → output_2.md
```

shogunでは「RACE-001」というルールIDまで振って、同一ファイルへの書き込みが禁止されています。競合リスクがある場合は即座にblocked報告を上げさせる設計です。

統合プラットフォームでは`sessions_spawn`が隔離セッションで動作するため、根本的にファイル競合が発生しません。

### 4. エラーハンドリングの3層構造

shogunでは、エラー発生時のエスカレーションパスが明確に定義されています。

| ステータス | 意味 | 対処 |
|-----------|------|------|
| `done` | 正常完了 | 戦果テーブルに記録 |
| `failed` | 技術的失敗 | リトライ可否判断 → 別足軽に再割当 or エスカレーション |
| `blocked` | 人間判断必要 | dashboard.md「🚨要対応」セクションに記載 |

足軽 → 家老（リトライ判断）→ 将軍（殿への報告）→ 殿（最終判断）と、4段階のエスカレーションパスがあります。

統合プラットフォームでは司令塔AIが直接判断します。中間層がないため迅速ですが、判断の品質は司令塔の能力に依存します。shogunの3層構造は、エージェント数が多い場合のフィルタリングとして合理的な設計だと感じました。

### 5. 非同期ステータス共有の工夫

shogunの設計で最も面白いと感じたのが、`dashboard.md`による非同期ステータス共有です。

```markdown
## 🚨 要対応 - 殿のご判断をお待ちしております
### ライセンス選択【判断必要】
- MIT / GPL / Apache のいずれか

## 🔄 進行中
| 足軽 | タスク | 進捗 |
|------|--------|------|
| 足軽1 | API調査 | 実行中 |
| 足軽3 | テスト作成 | 実行中 |

## ✅ 本日の戦果
| 時刻 | 任務 | 結果 |
|------|------|------|
| 14:15 | DB設計 | ✅ 完了 |
```

更新は家老のみに限定されています（単一責任で競合防止）。将軍や足軽はdashboard.mdを更新しません。この制約が、情報の一貫性を保証しています。

統合プラットフォームではHEARTBEAT.mdが似た役割を果たしますが、構造化の度合いではshogunのdashboard.mdに学ぶ点があります。エージェント数が増えた際の拡張パターンとして参考になりそうです。

## 定量比較

| 観点 | shogun（tmux方式） | 統合プラットフォーム |
|------|-------------------|---------------------|
| セットアップ | bashスクリプト+tmux9ペイン | 設定ファイルのみ |
| 常駐インスタンス | 10（将軍+家老+足軽8） | 1（司令塔のみ） |
| 並列度 | 8固定 | 動的（必要数だけ起動） |
| タスク受け渡し | YAMLファイル経由 | API直接呼び出し |
| 通信安定性 | send-keys依存（不安定） | API経由（安定） |
| トークン効率 | 全インスタンス常駐で消費 | 必要時のみ消費 |
| エラー伝播 | 3層（足軽→家老→将軍） | 1層（直接判断） |
| ファイル競合 | ルールで回避（RACE-001） | 隔離セッションで根絶 |
| 記憶機構 | Memory MCP（知識グラフ） | ファイルベース（MEMORY.md） |

## なぜ移行したか

### Claude Codeオーケストレーション機能の登場

shogunの導入直後、Claude Code本体にagent teams / orchestration機能が追加されました。

- 将軍の役割 → Claude Codeが内蔵
- 家老の役割 → タスク分解もClaude Codeが自動で処理
- 足軽の役割 → サブエージェントとして自動起動

shogunが解決していた問題の多くが、プラットフォーム側で吸収された形です。shogunの設計が悪かったのではなく、ツールの進化が追いついたというのが正確なところだと思います。

### 統合プラットフォームとの併用が不要に

自分の環境では、OpenClawの`sessions_spawn`がshogunと同等の機能をより少ないセットアップで提供していました。

```
# shogunの場合（起動スクリプト + 指示書読み込み）
./shutsujin_departure.sh
tmux attach -t shogun
> "このタスクを実行せよ"

# 統合プラットフォームの場合（即座に実行）
sessions_spawn(task="このタスクを実行せよ")
```

両方を維持する理由がなくなったため、統合プラットフォーム側に一本化しました。

## shogunから学んだ設計パターン

shogunは使わなくなりましたが、その設計思想には統合プラットフォームでも応用できるパターンがありました。

### 1. 単一責任による競合防止

dashboard.mdの更新者を家老だけに限定した設計は、分散システムにおける「ライターは1つ」の原則そのものです。マルチエージェント環境では、誰が何を書くかを明示的に制約することが安定性の鍵になります。

### 2. 構造化されたエスカレーション

「足軽はblocked報告を上げるだけ、判断は上位に委ねる」という設計は、エージェント数が増えた際にスケールします。現行の「司令塔が全部判断」方式は、エージェント数が少ないうちは最適ですが、スケールには限界がありそうです。

### 3. ペルソナの使い分け

足軽がタスクに応じて「シニアエンジニア」「テクニカルライター」とペルソナを切り替える設計は面白いです。「戦国風の挨拶だけで、コードはプロ品質」という分離は、AIエージェントの出力品質を上げる実用的なテクニックだと思います。

### 4. スキル化候補の自動検出

足軽が毎回の報告で「この作業はスキル化できるか？」を自己判断する仕組みがあります。ナレッジマネジメントの自動化として、他の環境でも応用できそうです。

## まとめ

マルチエージェントオーケストレーションは、ツールの進化が速い領域です。導入したツールが短期間でプラットフォームに吸収されることもあります。

ただ、multi-agent-shogunのようなOSSを実際に運用したからこそ見えるものがありました。tmuxベースのアプローチで直面する制約を知っているからこそ、API通信の安定性のありがたみがわかります。レースコンディション対策のルール設計を読んだからこそ、隔離セッションの価値が理解できます。

マルチエージェント開発を始める方へ。

1. **まず統合プラットフォームを試す。** セットアップコストが圧倒的に低い
2. **ただし設計パターンは学ぶ価値がある。** multi-agent-shogunのようなOSSには、単一責任・構造化エスカレーション・非同期ステータス共有など、ツールが変わっても活きる知見が詰まっている
3. **移行を恐れない。** より良いツールが出たら乗り換える柔軟さを持つ

## 関連記事

- [AIに仕事を任せる技術 — AI司令塔×マルチエージェント実践](https://zenn.dev/imudak/articles/ai-autonomous-dev-practice)
- [multi-agent-shogun（fork元）](https://github.com/yohey-w/multi-agent-shogun)

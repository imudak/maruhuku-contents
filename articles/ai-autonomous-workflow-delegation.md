---
title: "AI自律ワークフローの段階的委譲モデル — 1人社長×AIで100プロジェクトを回す運用設計"
emoji: "🎯"
type: "tech"
topics: ["ai", "workflow", "automation", "claude"]
published: false
---

## はじめに — AIエージェントの「現実」と「期待」のギャップ

2025年、AIエージェントへの期待は最高潮に達している。しかし現実のデータは冷静だ。

**METR（Model Evaluation & Threat Research）の研究（2025年7月）** によれば、経験豊富な開発者がAIコーディングツールを使用した場合、タスク完了までの時間が **平均19%遅くなった**。AIが万能の加速装置ではないことを示す衝撃的な結果だ。効果はタスクの性質と開発者の習熟度に大きく依存する。

業界全体を見ても、エンタープライズでAIエージェントを本番投入しているのは **全体の5%未満**。しかもそのほぼ全てが human-in-the-loop（人間が監視・承認するループ）を前提としている。

なぜか。理由の一つは **複合エラーの蓄積** だ。各ステップの成功率が90%だとしても、10ステップの連鎖では成功率は `0.9^10 ≈ 0.35`、つまり **65%が失敗する**。AIに長いワークフローを丸投げすると、エラーが雪だるま式に膨らむ。

一方で、Deloitteは **2028年までに日常業務判断の15%がAI自律判断に移行する** と予測している。完全自律は遠いが、段階的な委譲は確実に進む。

この記事では、筆者が1人社長として合同会社を経営しながら、AIエージェントに41件のプロジェクトを自律開発させている実践から得た **「段階的委譲モデル」** を紹介する。理論ではなく、動いているシステムの設計図だ。記事執筆後も運用を続け、委譲モデル自体が独立プロジェクトに発展するまでの過程も含めて紹介する。

## 前提 — 1人社長×AIの運用体制

筆者の会社では、AIエージェント（Claudeベース、社内名「クロウ候」）が開発の主力を担っている。

**規模感：**
- プロジェクト管理台帳（社内名「百式」）に **41件** のプロジェクトを登録
- Webアプリ、Chrome拡張、Flutterアプリ、業務自動化ツールなど多岐にわたる
- 人間は筆者1人。コードを書くのはほぼ全てAI

**自動化基盤（現在の構成）：**
- **事務総長**（flow-manager）: 6時間おきに全プロジェクトのヘルスチェックを実行。ビルド状態、依存関係の更新、ステータス整合性を監視
- **jimucho**（業務管理API）: SQLite + REST APIで業務データを一元管理。当初はNotionと連携していたが、**Phase 2でNotion書き込みを完全廃止**し、全cronジョブがjimucho API（`http://localhost:3100`）経由に統一された

```
┌─────────────┐     6h cycle      ┌──────────────┐
│  事務総長     │ ───────────────→ │  百式（SQLite）│
│ flow-manager │ ←─────────────── │  41 projects  │
└──────┬──────┘   status check    └──────────────┘
       │
       │ anomaly detected / cron trigger
       ▼
┌─────────────┐   REST API        ┌──────────────┐
│  クロウ候     │ ←──────────────── │  jimucho     │
│  AI Agent   │   localhost:3100  │  (SQLite)    │
└──────┬──────┘                   └──────────────┘
       │
       │ needs approval?
       ▼
   ┌────────┐
   │ imudak │  ← ここだけボトルネック
   └────────┘
```

**Notion脱却の理由：**  
NotionはAPIのレート制限が厳しく、LLMのコンテキストを余分に消費し、AIがCRUD操作しにくい構造だった。SQLite + REST APIに変えたことで、AI→API→DB の流れが劇的にシンプルになった。

そして問題が見えてきた。41件のプロジェクトを回していると、常時3〜5件が **「imudak待ち」** 状態になる。AIが作業を完了して承認を待っている、あるいは次の方針を聞いている状態だ。AIの処理速度が上がるほど、人間の判断待ち時間が相対的に大きくなる。

## 段階的委譲モデル — 4つのレベル

この問題に対する解が **段階的委譲モデル** だ。全てを丸投げするのでも、全てを承認するのでもなく、判断の性質に応じて4段階に分ける。

### Level 0: 決定論的自動化

**AIの判断は不要。ルールが明確で、入力に対して出力が一意に決まる処理。**

```yaml
# Level 0の例
triggers:
  - cron: "0 */6 * * *"    # 6時間おき
  - event: "build_failure"   # ビルド失敗時

actions:
  - health_check: all_projects
  - notify_if: status_mismatch
  - auto_restart: if_known_pattern
```

具体例：
- cronベースのヘルスチェック（事務総長が実行）
- ビルド失敗時の自動リトライ
- 依存パッケージの自動更新チェック
- ステータス不整合の自動検出・通知

Level 0は「自動化」であって「自律」ではない。判断がないので失敗しても影響範囲が限定的。ここを厚くすることが全体の安定性につながる。

### Level 1: 制約付き自律判断

**AIが判断するが、明確なルールの範囲内。事後報告のみで事前承認は不要。**

これが今回のモデルの核心だ。以下の4つのルールを設計した。

#### ルール1: 優先順位の自動決定

```python
def decide_next_project(projects: list[Project]) -> Project:
    """AIが次に着手するプロジェクトを自律的に選択"""
    scored = []
    for pj in projects:
        score = 0
        if pj.status == "実装中":
            score += 10  # 継続中のものを優先
        if pj.status == "MVP完了" and pj.has_pending_feedback:
            score += 8   # フィードバック対応
        if pj.blocked_by:
            score -= 20  # ブロックされているものは後回し
        if pj.estimated_hours < 4:
            score += 5   # 短時間で終わるものにボーナス
        scored.append((score, pj))
    return max(scored, key=lambda x: x[0])[1]
```

百式のステータス、依存関係、推定コストから次に着手するプロジェクトをAIが選ぶ。筆者の事前承認は不要。選択理由はjimucho activity APIに記録される（`POST /api/activity` で `type: "autonomous_log"`）。

#### ルール2: 小規模PJの自律Go

```
IF estimated_mvp_time <= 2 weeks
   AND estimated_cost <= $50
THEN → AIが自律的に着手OK（百式登録 + 事後報告）
ELSE → imudakの承認を待つ
```

MVP2週間以内、コスト$50以下のプロジェクトは、AIが自分で判断して開発を開始できる。

#### ルール3: 撤退の自律判断

```
IF no_progress_for >= 2 weeks
   AND blocked_by == "external_dependency"
THEN → ステータスを「中断」に変更
       撤退理由をjimucho activity APIに記録
       imudakへの事後報告
```

2週間進捗なし、かつ外部依存でブロックされている場合、AIが自律的に中断判断を行う。

#### ルール4: 失敗時のロールバック

開発環境はjj（Jujutsu、Gitの代替VCS）を使っているため、実装ミスは全て `jj op log` から復元できる。本番デプロイのロールバックもAIの自律判断で実行OK。これは技術選定が委譲モデルを支えている例だ。「元に戻せる」という保証があるからこそ、AIに判断を委ねられる。

### Level 2: 戦略的提案

**AIが考え、人間が選ぶ。AIは選択肢を提示するが、最終決定は人間。**

#### 週次フォーカス提案

毎週月曜日に、AIが「今週のフォーカス3件」を提案する。

```markdown
## 今週のフォーカス提案（2月第3週）

1. **jimucho v2.0** — ダッシュボードにリアルタイム通知追加
   - 理由: 5件のPJが「確認待ち」で滞留中。通知で解消見込み
   - 推定工数: 3日

2. **百式メトリクス** — PJ進捗の可視化
   - 理由: 41件の全体像が把握しづらくなっている
   - 推定工数: 2日

3. **Chrome拡張 v1.2** — ユーザーからのバグ報告3件対応
   - 理由: ストアレビューに影響。対応しないと評価低下リスク
   - 推定工数: 1日

→ ✅ / ❌ で承認してください。48h無回答の場合はこの提案で進行します。
```

ポイントは **「48時間無回答なら提案通り進行」** というデフォルト動作だ。人間がボトルネックにならないための安全弁として機能する。

### Level 3: 対外行動（人間承認必須）

**外部への影響がある行動は、必ず人間が承認する。ここは委譲しない。**

- アプリストアへの公開
- 外部サービスへの投稿・コメント
- 決済・課金に関わる操作
- 対外コミュニケーション（テスター募集、パートナー連絡）
- アカウント作成・認証情報の変更

対外行動は **取り消しが困難** で、**レピュテーションリスク** がある。AIの判断精度がどれだけ上がっても、ここだけは人間のゲートを残す。

## 委譲レベルの判定フロー

実際の運用では、新しいタスクが発生するたびにAIが以下のフローで委譲レベルを判定する。

```
新タスク発生
    │
    ├── ルールで出力が一意に決まる？ → Level 0（自動実行）
    │
    ├── 制約条件内で判断可能？
    │   ├── 2週間以内 & $50以下？ → Level 1（自律Go）
    │   ├── 撤退条件に該当？ → Level 1（自律中断）
    │   └── 優先順位判断？ → Level 1（自律選択）
    │
    ├── 戦略的判断が必要？ → Level 2（提案→承認）
    │
    └── 外部影響あり？ → Level 3（承認必須）
```

## 実装のポイント — 決定論的処理を分離する

重要な設計原則がある。**AIに判断させる前に、決定論的に処理できる部分を分離する** ことだ。

```typescript
// jimucho内の決定論的ステータス更新ロジック（簡略化）
function determineStatus(project: Project): Status | "needs_ai_judgment" {
  if (project.buildStatus === "failed") return "要修正";
  if (project.buildStatus === "success" && project.testsPassed) {
    if (project.allRequirementsCovered) return "MVP完了";
    return "needs_ai_judgment"; // ここだけAIに委ねる
  }
  return "needs_ai_judgment";
}
```

この原則をAIエージェント自身の実行にも適用している。

**MUSUBIプロセスで仕様を先に確定する：**  
新機能追加時は必ず `/sdd-requirements` から始める（MUSUBI = 要件→設計→実装の順序を強制するプロセス）。実装前に仕様を文書化することで、AIが「何を作るべきか」を迷わずに実装に集中できる。

**サブエージェントへの分業：**  
MUSUBI初期化、新規プロジェクト生成、定型ドキュメント作成などの決定論的作業は、専用のサブエージェントに委譲する。メインセッションは「何を作るか」の判断と報告に専念し、「どう作るか」の実行はサブエージェントに任せる。

```bash
# create-project.sh — 新規PJ生成の10ステップを自動化
# 1. ディレクトリ作成 → 2. jj init → 3. テンプレートコピー
# 4. プレースホルダー置換 → 5. musubi init → 6. jimucho API登録
# 7. CLAUDE.mdにpage_id埋め込み → 8. jj commit
# 9. GitHub repo作成 → 10. VS Codeワークスペース更新
~/projects/maruhuku-hub/scripts/create-project.sh my-new-project --category=アプリ
```

このスクリプトができる前は、新規プロジェクト作成のたびにメインセッションが10ステップを逐次実行していた。決定論的な作業をスクリプト化することで、メインセッションのコンテキストを節約できた。

## 実運用で分かったこと

委譲モデルを数ヶ月運用して、設計時には見えていなかったことが分かってきた。

### AIの「コンテキスト肥大化」が委譲を破壊する

最も意外な失敗がこれだ。

MEMORY.md と AGENTS.md（AIが毎セッション読む設定ファイル）が、運用を重ねるうちに **34KBまで膨れ上がった**。ルールを追記するたびにサイズが増え、AIがコンテキストウィンドウのコンパクション（自動要約）を行うと、後から追記したルールが消えていた。

**連鎖する問題：**
1. MEMORY.md が肥大化 → コンパクション発動
2. 「途中経過をDiscordに書くな」ルールが消える
3. AIが作業中に進捗を何度もDiscordに投稿する
4. imudakが「またやってる」と指摘する
5. ルールを再追記 → さらに肥大化

この悪循環を断ち切るために、MEMORY.md/AGENTS.md を **5KBに圧縮**した。削除したのは過去の実績記録や検討メモで、現在有効なルールだけを残した。過去記録はdaily memory（`memory/YYYY-MM-DD.md`）に分離した。

**学び：** AIの動作を支配するコンテキストファイルは「軽く保つ」ことが必須。ルールを増やしたいなら、古いルールを削るか別ファイルに分離する。

### Notion脱却がAI委譲を加速した

jimucho Phase 2でNotion書き込みを完全廃止し、全データアクセスをSQLite + REST APIに統一した。これが委譲モデルに大きく効いた。

**Before（Notion直接操作）：**
- AIがNotionページを読み書きするためにPage IDを覚える必要がある
- レート制限（毎秒3リクエスト）でバッチ処理が詰まる
- APIレスポンスがLLMには冗長なJSON構造

**After（jimucho API経由）：**
```bash
# シンプルなREST API。AIが迷わない
curl -X POST http://localhost:3100/api/activity \
  -H "Content-Type: application/json" \
  -d '{"type": "autonomous_log", "content": "delegation-model spec作成完了"}'

curl http://localhost:3100/api/projects?status=実装中
```

AIの視点からすると、NotionのAPIは「人間のUIを無理やりAPIにした」構造で、LLMが扱うには不向きだった。シンプルなREST APIに変えたことで、AIのコンテキスト消費が減り、エラーも激減した。

### 委譲モデル自体を「仕様書で管理する」

運用を続けると、委譲モデル自体が複雑になってくる。「このケースはL1でいいのか？」「エスカレーション条件の閾値は？」という判断がブレ始める。

対策として、委譲モデルを **独立プロジェクト（delegation-model）として仕様化**した。MUSUBIプロセス（要件→設計→実装）で要求仕様書を作り、以下を明文化した：

```markdown
## L1自律判断の閾値（仕様書より抜粋）

### Go条件（全て満たす場合）
- 推定期間: 2週間以内
- 推定コスト: $50以内
- 影響範囲: 自プロジェクト内のみ
- 可逆性: jj op log / git revert で戻せる

### エスカレーション条件（いずれか該当で即座にL2へ）
- 外部APIの本番環境への書き込み
- ユーザーデータに触れる変更
- 課金・決済フローへの影響
- 推定コストが$50を超える可能性

### 監査ログ（全L1判断で必須）
POST /api/activity
{
  "type": "autonomous_log",
  "content": "判断内容・根拠・実行結果"
}
```

ルールを自然言語でAGENTS.mdに書くだけでは曖昧さが残る。構造化された仕様書があることで、AIが判断ブレを起こしにくくなる。

### 決定論的作業はサブエージェントに投げきる

メインセッションのAI（クロウ候）が「実装作業」と「判断・報告」を両方やろうとすると、コンテキストが肥大化してルール違反が起きやすくなる。

現在の運用では、メインセッションは以下に専念する：
- **判断**: 次に何を作るか、L2承認内容のまとめ
- **報告**: 完了時にDiscordに1通だけ

実装・調査・ドキュメント整備はサブエージェント（`sessions_spawn`）に委譲する。サブエージェントは軽量なコンテキストで専門的な作業に集中でき、メインセッションは常に「軽い状態」を保てる。

## 定量的な変化

この段階的委譲モデルを導入して数ヶ月。測定できる変化を記録している。

**「imudak待ち」の削減：**
- 導入前: 常時3〜5件が滞留
- 導入後: 常時0〜2件に削減
- Level 1の自律判断により、「聞くまでもない判断」でプロジェクトが止まらなくなった

**プロジェクト回転速度：**
- 導入前: 月間MVP完了 2〜3件
- 導入後: 月間MVP完了 5〜7件

**事故・ロールバック：**
- Level 1の自律判断による事故: 数ヶ月で2件
- いずれもjjによるロールバックで即復旧。影響範囲は軽微
- 「AIが勝手に判断して取り返しのつかない事態になった」ケースはゼロ

## 導入のための実践ガイド

この委譲モデルを自分の環境に導入するためのステップを整理する。

### Step 1: 現状の判断フローを棚卸しする

まず、AIに依頼しているタスクを全てリストアップし、それぞれの判断内容を分類する。

```markdown
| タスク | 判断内容 | 現状 | 理想レベル |
|--------|---------|------|----------|
| ビルド監視 | 異常検知 | 手動確認 | Level 0 |
| 次のPJ選択 | 優先順位 | 毎回相談 | Level 1 |
| 新PJ企画 | 方向性 | 都度承認 | Level 2 |
| ストア公開 | 品質判断 | 都度承認 | Level 3 |
```

### Step 2: Level 0を厚くする

最初にやるべきは、Level 0（決定論的自動化）の範囲を広げること。判断不要な処理をコードに落とし込む。ここが厚いほど、上位レベルの負荷が下がる。

### Step 3: Level 1のルールを明文化する（数値で）

「制約条件」を具体的な数値で定義する。曖昧なルールはAIの解釈ブレを生む。

```yaml
# 良い例: 具体的な閾値
autonomous_go:
  max_mvp_duration: "2 weeks"
  max_cost: "$50"
  requires: ["百式登録", "事後報告"]

# 悪い例: 曖昧な条件
autonomous_go:
  condition: "小規模なプロジェクトならOK"  # 「小規模」の定義は？
```

### Step 4: コンテキストファイルを軽く保つ

AIが毎回読むコンテキストファイル（AGENTS.md相当）のサイズを定期的に見直す。目安は **5KB以下**。肥大化したら古いルールを削除するか、参照先に分離する。

### Step 5: 48時間ルールを導入する

Level 2の提案に対して、無回答時のデフォルト動作を定義する。「人間が応答しなかったらどうするか」を事前に決めておくことで、人間のボトルネック化を防ぐ。

### Step 6: Level 3は動かさない

対外行動の承認ゲートは、信頼関係がどれだけ構築されても安易に下げない。AIの能力が向上しても、対外行動のリスク構造は変わらないからだ。

## まとめ — 「全自動」ではなく「適切な委譲」

AIエージェントの活用において、「全部任せる」と「全部確認する」の間に巨大なスペクトルがある。段階的委譲モデルは、このスペクトルを4つのレベルに構造化し、タスクの性質に応じて最適な委譲度を選ぶフレームワークだ。

**設計の要点：**
1. **決定論的処理を最大化する**（Level 0を厚く）
2. **自律判断には明確な制約を設ける**（Level 1のルールは数値で）
3. **AIのコンテキストを軽く保つ**（設定ファイルは5KB以下を目安に）
4. **Notion等の複雑なAPIより、シンプルなREST APIを用意する**
5. **委譲モデル自体を仕様書で管理する**（delegation-model化）
6. **人間のボトルネック化を防ぐ安全弁を用意する**（48hルール）
7. **対外行動の承認ゲートは下げない**（Level 3は不変）
8. **ロールバック可能な技術基盤を選ぶ**（jj、冪等なAPI設計）

運用を続けるほど、委譲モデル自体も改良が必要になる。判断閾値の見直し、エスカレーションルールの精緻化、監査ログの充実——これらを「仕様書に書いてMUSUBIプロセスで管理する」サイクルに乗せることで、委譲モデルが自己改善していく。

Deloitteの予測通り、AI自律判断の範囲は今後も広がる。だが「いつか全自動になる」を待つのではなく、**今日から段階的に委譲範囲を広げていく** のが実務者のアプローチだ。

41件のプロジェクトを1人で回す。その現実が、このモデルを生んだ。そしてモデル自体が次のプロジェクトになった。

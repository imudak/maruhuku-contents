---
title: "AI自律ワークフローの段階的委譲モデル — 1人で40件のプロジェクトを回すための設計"
emoji: "🎯"
type: "tech"
topics: ["ai", "workflow", "automation", "claude"]
published: false
---

## 動機 — 常時5件が「承認待ち」だった

合同会社を1人で経営しながら、AIエージェント（Claudeベース）を使って40件超のプロジェクトを並走させています。Webアプリ、Chrome拡張、Flutterアプリ、業務自動化ツールなど種類はバラバラで、コードを書くのはほぼ全てAIです。

しばらく運用していると、困ったことが起きました。常時3〜5件が「承認待ち」になるのです。AIが作業を完了して次の判断を待っている、あるいは方針を聞いている状態です。AIの処理が速くなるほど、人間の応答待ち時間が相対的に大きくなっていきました。

この問題を解決するために考えたのが段階的委譲モデルです。全てをAIに丸投げするのでも、全てを承認するのでもなく、判断の性質に応じて4段階に分けるという設計です。数ヶ月運用して見えてきたことも含めて書きます。

## 自動化基盤の現在の構成

段階的委譲の話をする前に、現在の基盤を説明します。

社内で「事務総長」と呼んでいるflow-managerが6時間おきに全プロジェクトのヘルスチェックを実行しています。ビルド状態、依存関係の更新、ステータス整合性の監視が主な仕事です。

業務データの管理は「jimucho」というSQLite + REST APIのシステムに一元化しています。以前はNotionと連携していましたが、Phase 2でNotion書き込みを完全廃止しました。現在は全cronジョブがjimucho API（`http://localhost:3100`）経由で動いています。

```
┌─────────────┐     6h cycle      ┌──────────────┐
│  事務総長     │ ───────────────→ │  百式（SQLite）│
│ flow-manager │ ←─────────────── │  40+ projects │
└──────┬──────┘   status check    └──────────────┘
       │
       │ anomaly detected / cron trigger
       ▼
┌─────────────┐   REST API        ┌──────────────┐
│  クロウ候     │ ←──────────────── │  jimucho     │
│  AI Agent   │   localhost:3100  │  (SQLite)    │
└──────┬──────┘                   └──────────────┘
       │
       │ needs approval?
       ▼
   ┌────────┐
   │ imudak │
   └────────┘
```

NotionからSQLite + REST APIに変えた理由は、AIが扱いやすくなるからです。NotionのAPIはレート制限が厳しく、LLMのコンテキストを余分に消費し、CRUD操作がしにくい構造でした。シンプルなREST APIに変えたことで、AI→API→DBの流れが整理されました。

## 段階的委譲モデルの4レベル

### Level 0: 決定論的な自動化

AIの判断を必要としない処理です。ルールが明確で、入力に対して出力が一意に決まります。

```yaml
triggers:
  - cron: "0 */6 * * *"
  - event: "build_failure"

actions:
  - health_check: all_projects
  - notify_if: status_mismatch
  - auto_restart: if_known_pattern
```

具体的には、cronベースのヘルスチェック、ビルド失敗時の自動リトライ、依存パッケージの更新チェック、ステータス不整合の自動検出と通知などです。

Level 0は「自動化」であって「自律」ではありません。判断がないので失敗しても影響範囲が限定的です。ここを厚くすることが全体の安定性につながります。

### Level 1: 制約付き自律判断

AIが判断しますが、明確なルールの範囲内に限ります。事後報告のみで事前承認は不要です。

このモデルの核心部分です。以下の4つのルールを設計しました。

**優先順位の自動決定**

```python
def decide_next_project(projects: list[Project]) -> Project:
    scored = []
    for pj in projects:
        score = 0
        if pj.status == "実装中":
            score += 10  # 継続中のものを優先
        if pj.status == "MVP完了" and pj.has_pending_feedback:
            score += 8
        if pj.blocked_by:
            score -= 20  # ブロックされているものは後回し
        if pj.estimated_hours < 4:
            score += 5   # 短時間で終わるものにボーナス
        scored.append((score, pj))
    return max(scored, key=lambda x: x[0])[1]
```

プロジェクト管理台帳（百式）のステータス、依存関係、推定コストから次に着手するプロジェクトをAIが選びます。選択理由はjimucho activity APIに記録します（`POST /api/activity` で `type: "autonomous_log"`）。

**小規模プロジェクトの自律Go**

```
IF estimated_mvp_time <= 2 weeks
   AND estimated_cost <= $50
THEN → AIが自律的に着手OK（百式登録 + 事後報告）
ELSE → 承認を待つ
```

MVP2週間以内、コスト$50以下のプロジェクトは、AIが自分で判断して開発を開始できます。

**撤退の自律判断**

```
IF no_progress_for >= 2 weeks
   AND blocked_by == "external_dependency"
THEN → ステータスを「中断」に変更
       撤退理由をjimucho activity APIに記録
       事後報告
```

2週間進捗なし、かつ外部依存でブロックされている場合、AIが自律的に中断判断を行います。

**失敗時のロールバック**

開発環境はjj（Jujutsu）を使っているため、実装ミスは全て `jj op log` から復元できます。本番デプロイのロールバックもAIの自律判断で実行しています。「元に戻せる」という保証があるから、AIに判断を委ねられます。技術選定が委譲モデルを支えている例です。

### Level 2: 戦略的提案

AIが考え、人間が選びます。AIは選択肢を提示しますが、最終決定は人間です。

毎週月曜日に、AIが「今週のフォーカス3件」を提案します。

```markdown
## 今週のフォーカス提案（2月第3週）

1. **jimucho v2.0** — ダッシュボードにリアルタイム通知追加
   - 理由: 5件のPJが「確認待ち」で滞留中。通知で解消見込み
   - 推定工数: 3日

2. **百式メトリクス** — PJ進捗の可視化
   - 理由: 40件超の全体像が把握しづらくなっている
   - 推定工数: 2日

3. **Chrome拡張 v1.2** — バグ報告3件対応
   - 理由: ストアレビューに影響。対応しないと評価低下リスク
   - 推定工数: 1日

→ ✅ / ❌ で承認してください。48h無回答の場合はこの提案で進行します。
```

「48時間無回答なら提案通り進行」というデフォルト動作がポイントです。人間がボトルネックにならないための安全弁として機能しています。

### Level 3: 対外行動（人間承認必須）

外部への影響がある行動は、必ず人間が承認します。ここは委譲しません。

- アプリストアへの公開
- 外部サービスへの投稿・コメント
- 決済・課金に関わる操作
- 対外コミュニケーション（テスター募集、パートナー連絡）
- アカウント作成・認証情報の変更

対外行動は取り消しが困難で、レピュテーションリスクもあります。AIの判断精度がどれだけ上がっても、ここだけは人間のゲートを残します。

## 委譲レベルの判定フロー

新しいタスクが発生するたびにAIが以下のフローで委譲レベルを判定します。

```
新タスク発生
    │
    ├── ルールで出力が一意に決まる？ → Level 0（自動実行）
    │
    ├── 制約条件内で判断可能？
    │   ├── 2週間以内 & $50以下？ → Level 1（自律Go）
    │   ├── 撤退条件に該当？    → Level 1（自律中断）
    │   └── 優先順位判断？      → Level 1（自律選択）
    │
    ├── 戦略的判断が必要？ → Level 2（提案→承認）
    │
    └── 外部影響あり？ → Level 3（承認必須）
```

## 実装のポイント — 決定論的処理の分離

重要な設計方針として、AIへの委ねの前段階で決定論的処理を分離しています。

```typescript
function determineStatus(project: Project): Status | "needs_ai_judgment" {
  if (project.buildStatus === "failed") return "要修正";
  if (project.buildStatus === "success" && project.testsPassed) {
    if (project.allRequirementsCovered) return "MVP完了";
    return "needs_ai_judgment"; // ここだけAIに委ねる
  }
  return "needs_ai_judgment";
}
```

この方針をAIエージェント自身の実行にも適用しています。

新機能追加時は必ず `/sdd-requirements` から始めます（MUSUBI = 要件→設計→実装の順序を強制するプロセス）。仕様を先に文書化することで、AIが何を作るかを迷わず実装へ集中できます。

MUSUBI初期化、新規プロジェクト生成、定型ドキュメント作成などの決定論的作業は、専用のサブエージェントに委譲しています。メインセッションは判断と報告に専念し、実行はサブエージェントに任せます。

```bash
# 新規PJ生成の10ステップを自動化するスクリプト
# 1. ディレクトリ作成 → 2. jj init → 3. テンプレートコピー
# 4. プレースホルダー置換 → 5. musubi init → 6. jimucho API登録
# 7. CLAUDE.mdにpage_id埋め込み → 8. jj commit
# 9. GitHub repo作成 → 10. VS Codeワークスペース更新
~/projects/maruhuku-hub/scripts/create-project.sh my-new-project --category=アプリ
```

このスクリプトができる前は、新規プロジェクト作成のたびにメインセッションが10ステップを逐次実行していました。決定論的な作業をスクリプト化することで、メインセッションのコンテキストを節約できました。

## 数ヶ月運用して気づいたこと

### AIのコンテキスト肥大化が委譲を壊す

予想外の問題がこれでした。

AIが毎セッション読む設定ファイル（MEMORY.mdとAGENTS.md）が、運用を重ねるうちに34KBまで膨れ上がりました。ルールを追記するたびにサイズが増え、AIがコンテキストウィンドウのコンパクション（自動要約）を行うと、後から追記したルールが消えていきました。

連鎖する問題はこうです。MEMORY.mdが肥大化するとコンパクションが発動します。「途中経過をDiscordに書くな」ルールが消えます。AIが作業中に進捗を何度もDiscordに投稿します。指摘するとルールを再追記します。さらに肥大化します。

この悪循環を断ち切るために、MEMORY.md/AGENTS.mdを5KBに圧縮しました。削除したのは過去の実績記録や検討メモで、現在有効なルールだけを残しました。過去記録はdaily memory（`memory/YYYY-MM-DD.md`）に分離しています。

AIの動作を支配するコンテキストファイルは「軽く保つ」のが必須です。ルールを増やしたいなら、古いルールを削るか別ファイルに分離するかのどちらかです。

### Notion脱却が委譲を加速した

jimucho Phase 2でNotion書き込みを完全廃止し、全データアクセスをSQLite + REST API経由で統一しました。これが委譲モデルへ想定以上の効果をもたらしました。

Notion直接操作の頃は、AIがNotionページを読み書きするためにPage IDを覚える必要がありました。レート制限（毎秒3リクエスト）でバッチ処理が詰まり、APIレスポンスがLLMには冗長なJSON構造でした。

jimucho API経由に変えてからはシンプルになりました。

```bash
# AIが迷わないシンプルなREST API
curl -X POST http://localhost:3100/api/activity \
  -H "Content-Type: application/json" \
  -d '{"type": "autonomous_log", "content": "delegation-model spec作成完了"}'

curl http://localhost:3100/api/projects?status=実装中
```

NotionのAPIは「人間のUIを無理やりAPIにした」構造で、LLMが扱うには不向きでした。シンプルなREST APIに変えたことで、AIのコンテキスト消費が減り、エラーも減りました。

### 委譲モデル自体を仕様書で管理する

運用を続けると、委譲モデル自体が複雑になってきます。「このケースはL1でいいのか」「エスカレーション条件の閾値は」という判断がブレ始めます。

対策として、委譲モデルを独立プロジェクト（delegation-model）として仕様化しました。MUSUBIプロセス（要件→設計→実装）で要求仕様書を作り、以下を明文化しています。

```markdown
## L1自律判断の閾値（仕様書より抜粋）

### Go条件（全て満たす場合）
- 推定期間: 2週間以内
- 推定コスト: $50以内
- 影響範囲: 自プロジェクト内のみ
- 可逆性: jj op log / git revert で戻せる

### エスカレーション条件（いずれか該当で即座にL2へ）
- 外部APIの本番環境への書き込み
- ユーザーデータに触れる変更
- 課金・決済フローへの影響
- 推定コストが$50を超える可能性

### 監査ログ（全L1判断で必須）
POST /api/activity
{
  "type": "autonomous_log",
  "content": "判断内容・根拠・実行結果"
}
```

ルールを自然言語でAGENTS.mdに書くだけでは曖昧さが残ります。構造化された仕様書があることで、AIの判断ブレが起きにくくなりました。

### メインセッションは判断と報告に専念する

メインセッションのAIが「実装作業」と「判断・報告」を両方やろうとすると、コンテキストが肥大化してルール違反が起きやすくなります。

現在の運用では、メインセッションが担うのは判断（次に何を作るか、L2承認内容のまとめ）とDiscord報告だけです。実装・調査・ドキュメント整備はサブエージェントに委譲しています。サブエージェントは軽量なコンテキストで専門的な作業に集中でき、メインセッションは常に「軽い状態」を保てます。

## 測定できた変化

段階的委譲モデルを導入して数ヶ月、変化を記録しています。

「承認待ち」の件数は導入前の常時3〜5件から、導入後は0〜2件に減りました。Level 1の自律判断により、「聞くまでもない判断」でプロジェクトが止まらなくなったためです。

月間MVP完了件数は導入前の2〜3件から5〜7件に増えています。

Level 1の自律判断による事故は数ヶ月で2件ありました。いずれもjjによるロールバックで即復旧し、影響範囲は軽微でした。「AIが勝手に判断して取り返しのつかない事態になった」ケースは今のところゼロです。

## 自分の環境に導入するなら

### Step 1: 現状の判断フローを棚卸しする

まず、AIに依頼しているタスクを全てリストアップし、それぞれの判断内容を分類します。

| タスク | 判断内容 | 現状 | 理想レベル |
|--------|---------|------|----------|
| ビルド監視 | 異常検知 | 手動確認 | Level 0 |
| 次のPJ選択 | 優先順位 | 毎回相談 | Level 1 |
| 新PJ企画 | 方向性 | 都度承認 | Level 2 |
| ストア公開 | 品質判断 | 都度承認 | Level 3 |

### Step 2: Level 0を厚くする

最初にやるべきは、Level 0（決定論的な自動化）の範囲を広げることです。判断不要な処理をコードに落とし込みます。ここが厚いほど、上位レベルの負荷が下がります。

### Step 3: Level 1のルールを数値で定義する

制約条件を具体的な数値で定義します。曖昧なルールはAIの解釈ブレを生みます。

```yaml
# 良い例: 具体的な閾値
autonomous_go:
  max_mvp_duration: "2 weeks"
  max_cost: "$50"
  requires: ["百式登録", "事後報告"]

# 悪い例: 曖昧な条件
autonomous_go:
  condition: "小規模なプロジェクトならOK"
```

### Step 4: コンテキストファイルを軽く保つ

AIが毎回読むコンテキストファイルのサイズを定期的に見直します。目安は5KB以下です。肥大化したら古いルールを削除するか、参照先に分離します。

### Step 5: 48時間ルールを導入する

Level 2の提案に対して、無回答時のデフォルト動作を定義します。「人間が応答しなかったらどうするか」を事前に決めておくことで、人間のボトルネック化を防げます。

### Step 6: Level 3は動かさない

対外行動の承認ゲートは安易に下げません。AIの能力が向上しても、対外行動のリスク構造は変わらないからです。

## まとめ

段階的委譲モデルの要点は以下の通りです。

- 決定論的処理を最大化する（Level 0を厚く）
- 自律判断には明確な制約を設ける（Level 1のルールは数値で）
- AIのコンテキストを軽く保つ（設定ファイルは5KB以下を目安に）
- シンプルなREST APIを用意する（NotionなどのUIベースAPIより扱いやすい）
- 委譲モデル自体を仕様書で管理する（delegation-model化）
- 人間のボトルネック化を防ぐ安全弁を用意する（48hルール）
- 対外行動の承認ゲートは下げない（Level 3は不変）
- ロールバック可能な技術基盤を選ぶ（jj、冪等なAPI設計）

運用を続けるほど委譲モデル自体も改良が必要になります。判断閾値の見直し、エスカレーションルールの精緻化、監査ログの充実——これらをMUSUBIプロセスで管理するサイクルに乗せることで、委譲モデルが徐々に整備されていきます。

40件超のプロジェクトを1人で回す必要に迫られてできた設計です。委譲モデル自体が今や独立プロジェクトになっているあたりに、この手のシステムの特性が出ているなと思っています。

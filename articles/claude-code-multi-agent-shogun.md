---
title: Claude Codeのマルチエージェント実行を理解する - multi-agent-shogunから学ぶ
emoji: 🏯
type: tech
topics:
  - ClaudeCode
  - AI
  - マルチエージェント
  - tmux
  - 開発環境
published: true
---

# Claude Codeのマルチエージェント実行を理解する

## きっかけ

[@shio_shoppaize](https://zenn.dev/shio_shoppaize)さんの記事「[Claude Codeで「AI部下10人」を作ったら、勝手にバグ直して「違反は切腹」ルールを追加してきて、オレは適当にしゃべるだけになった](https://zenn.dev/shio_shoppaize/articles/5fee11d03a11a1)」を読んで、思わずうなってしまいました。

自分のプロジェクトでも[MUSUBI](https://www.npmjs.com/package/musubi-sdd)というフレームワークを使っており、25個以上のエージェント定義があります。「なんだ、似たようなことをすでにやっているじゃないか」と最初は思いました。ところが、読み進めると根本的な違いが見えてきます。

「定義がある」と「実際に機能している」は、まったくの別物でした。

## multi-agent-shogunシステムの概要

記事で紹介されているシステムの構成はシンプルかつ強力です。

| 要素 | 内容 |
|------|------|
| 階層構造 | 将軍1名・家老1名・足軽8名（計10エージェント） |
| 通信方式 | YAMLファイルベース + tmux send-keys イベント駆動 |
| 実行環境 | WSL2 + tmux で9つのClaude Codeセッション並列管理 |
| コスト | Claude Max $100〜200/月で10エージェント運用 |

特徴的なのは「切腹ルール」です。将軍が課題を与えると、家老がタスクを細分化し、各足軽が専門分野を担当します。AI自身が「最小権限の原則（他の足軽の担当を奪うことを禁止）」を自発的に追加したというのが面白いところです。

## Claude Codeのスキル実行はシングルエージェント

ここに重要な気づきがありました。

**スキルを実行しているとき、マルチエージェントになっているのか？**

答えは**No**です。

```text
現在のClaude Code動作:

User → Claude Code (1セッション)
           ↓
      スキル呼び出し（/steering等）
           ↓
      SKILL.mdがプロンプトに追加される
           ↓
      同じセッション内で処理継続
```

Claude Codeのスキルは「役割を切り替える」だけであり、物理的には**1つのClaude Codeセッション**が順次処理しています。25個のエージェント定義があっても、それは「定義」であって「並列実行」ではありません。

これは当たり前のことかもしれませんが、自分は漫然と「スキルをたくさん定義すればマルチエージェントになる」と勘違いしていました。フレームワークの名前が「MUSUBI（結び）」で、複数エージェントの連携をイメージさせる名前だったことも混乱の一因でした。

## multi-agent-shogunの仕組み

記事のシステムは、物理的に複数のClaude Codeプロセスを起動しています。

```text
┌─────────────────────────────────────────────────────────┐
│ tmux session: multiagent                                │
├─────────────────────────────────────────────────────────┤
│ Window 0: shogun     │ Window 1: karo    │ Window 2    │
│ ┌─────────────────┐  │ ┌───────────────┐ │ ashigaru    │
│ │ claude          │  │ │ claude        │ │ ┌──┬──┬──┬──┐
│ │ (将軍セッション) │  │ │ (家老セッション)│ │ │1 │2 │3 │4 │
│ └─────────────────┘  │ └───────────────┘ │ ├──┼──┼──┼──┤
│                      │                   │ │5 │6 │7 │8 │
│                      │                   │ └──┴──┴──┴──┘
└─────────────────────────────────────────────────────────┘
```

### 起動と通信の流れ

1. 将軍がタスクをYAMLに書く（`queue/tasks/karo.yaml`）
2. `tmux send-keys` で家老を起こす
3. 家老がYAMLを読み、足軽用に分解する
4. `tmux send-keys` で各足軽を起こす
5. 足軽が完了したらステータスをYAMLに書く
6. 家老が完了を検知し、将軍に報告する

### イベント駆動のメリット

ポーリングではなく、必要時のみ通信するイベント駆動方式を採用しています。待機中はAPIを消費しません。

仮に「9体が5秒ごとにポーリング」としたら、1分あたり108リクエストが飛び続けることになります。そのコストは到底ペイしません。tmux send-keysでのイベント駆動は、このコスト問題をエレガントに解決しています。

## MUSUBIの現状（定義 vs 実運用）

自分のプロジェクトでのMUSUBIの使い方を正直に振り返ると、次の通りでした。

| 観点 | MUSUBIの状態 | 備考 |
|------|-------------|------|
| 役割分担 | 定義のみ | 27スキル定義あり、協調動作なし |
| ルール強制 | 定義のみ | 憲法相当の定義あり、自動検証なし |
| タスク分解 | 定義のみ | オーケストレーター未使用 |
| 並列実行 | なし | シングルセッションのみ |
| 進行状況の可視化 | なし | 監視機構なし |

MUSUBIはSDD（Specification Driven Development）の思想に基づいており、仕様を先に書いてAIに実装させるアプローチです。役割定義や憲法（行動規範）をMarkdownで管理できる点は強力です。しかし、肝心の「複数エージェントを動かす基盤」は自分で用意する必要があります。

言い換えると、MUSUBIは「何をするか」の定義を提供するが、「どう並列で協調させるか」の実装は含んでいません。

multi-agent-shogunはまさに逆で、「どう協調させるか」（tmux + YAML通信）の実装を提供しています。

## 両者を比較して見えてきたこと

この比較を通じて、マルチエージェント開発に必要な要素が整理されました。

| 要素 | 必要な仕掛け | multi-agent-shogun | MUSUBI |
|------|-------------|-------------------|--------|
| 並列実行 | 複数セッション起動 | ✅ tmux | ❌ なし |
| エージェント間通信 | ファイルベース or MCP | ✅ YAML | ❌ なし |
| タスク分配 | オーケストレーター | ✅ 将軍/家老 | ❌ 未使用 |
| 進行状況監視 | ダッシュボード等 | ✅ ステータスファイル | ❌ なし |
| 役割定義 | スキル/プロンプト | △ CLAUDE.md | ✅ 27スキル |
| 行動規範 | 憲法/ルール | ✅ 切腹ルール | ✅ 憲法定義 |

MUSUBIが強いのは「役割定義」と「行動規範」の部分。multi-agent-shogunが強いのは「実際に動かす基盤」の部分です。

## 実際に動かすために必要なもの

Claude Codeで真のマルチエージェント開発を実現するには、定義だけでなくインフラが必要です。

**最小構成（3エージェント）の例：**

```bash
# tmuxセッションを作成
tmux new-session -d -s multiagent

# 各エージェント用のウィンドウを作成
tmux new-window -t multiagent -n orchestrator
tmux new-window -t multiagent -n worker1
tmux new-window -t multiagent -n worker2

# 各ウィンドウでClaude Codeを起動
tmux send-keys -t multiagent:orchestrator "claude" Enter
tmux send-keys -t multiagent:worker1 "claude" Enter
tmux send-keys -t multiagent:worker2 "claude" Enter
```

タスクの受け渡しにはYAMLファイルを使います。

```yaml
# queue/tasks/worker1.yaml
task_id: task_001
status: pending
description: "APIエンドポイントの実装"
assigned_by: orchestrator
context:
  spec_file: "docs/api-spec.md"
```

これだけで、オーケストレーターがファイルに書いてエージェントを起こす、という基本的な協調が動き始めます。

## 学びと今後の方針

今回の比較で得た学びをまとめます。

**1. スキル定義 ≠ マルチエージェント**

スキルやエージェント定義は、あくまでプロンプトの整理術です。複数エージェントの並列実行は、別途インフラが必要です。

**2. 定義は資産、基盤は別に作る**

MUSUBIで蓄積した27スキル定義は資産です。multi-agent-shogunの枠組みで活用することで、「定義の豊富さ」と「実行基盤の堅牢さ」の両方を手に入れられます。

**3. イベント駆動でコストを抑える**

ポーリング型のマルチエージェントはコストが跳ね上がります。tmux send-keysのようなイベント駆動方式は、実用化のための重要な設計判断です。

**4. AIが自律的にルールを追加する段階に来ている**

「切腹ルール」のエピソードが象徴的です。AIが自分で「他の担当を奪うのは非効率だ」と判断してルールを書く。これは、単純なコード補完の話ではなく、協調作業のルール設計まで踏み込んできているということです。

### 採用オプション

- **オプションA**: multi-agent-shogunをベースに、MUSUBIの定義を活用する（実行基盤 + 専門スキルの両立）
- **オプションB**: MUSUBIにtmux並列実行レイヤーを追加する（既存システムを拡張）
- **オプションC**: 用途別に使い分ける（大規模タスクは並列実行、通常作業はシングルセッション）

自分のプロジェクトではオプションAを実際に試してみました。いきなり10エージェントではなく、まず3エージェント（オーケストレーター + ワーカー2名）から始め、その後さらに別の方式へと移行しています。実際に試した経緯と結果は[次の記事](https://zenn.dev/imudak/articles/multi-agent-orchestration-comparison)で書いています。

## まとめ

MUSUBIは「何をするか」（27スキル定義）を持っており、multi-agent-shogunは「どう協調させるか」（tmux + YAML通信）を持っています。両者は補完関係にあります。

「エージェントをたくさん定義した」だけではマルチエージェントにはなりません。物理的に複数プロセスを起動し、イベント駆動で通信させる基盤があってはじめて、協調が生まれます。

定義と実装のギャップを埋めることが、次のステップです。

## 参考・関連記事

- [Claude Codeで「AI部下10人」を作ったら〜](https://zenn.dev/shio_shoppaize/articles/5fee11d03a11a1)
- [MUSUBI - Specification Driven Development](https://www.npmjs.com/package/musubi-sdd)
- [マルチエージェントAI開発の現実 — tmux手動オーケストレーションから自律実行フローへの移行記](https://zenn.dev/imudak/articles/multi-agent-orchestration-comparison)（後編：shogunの実運用から移行まで）
- [LLMに決定論的な処理をさせていた話 — jimuchoの誕生](https://zenn.dev/imudak/articles/ai-autonomous-workflow-delegation)（マルチエージェント運用の中で生まれた決定論的処理の分離）

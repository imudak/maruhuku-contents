---
title: Claude Codeのマルチエージェント実行を理解する - multi-agent-shogunから学ぶ
emoji: 🏯
type: tech
topics:
  - ClaudeCode
  - AI
  - マルチエージェント
  - tmux
  - 開発環境
published: false
---

# Claude Codeのマルチエージェント実行を理解する

## きっかけ

[@shio_shoppaize](https://zenn.dev/shio_shoppaize)さんの記事「[Claude Codeで「AI部下10人」を作ったら、勝手にバグ直して「違反は切腹」ルールを追加してきて、オレは適当にしゃべるだけになった](https://zenn.dev/shio_shoppaize/articles/5fee11d03a11a1)」を読みました。

自分のプロジェクトでは[MUSUBI](https://www.npmjs.com/package/musubi-sdd)というフレームワークを使っており、25個のエージェント定義があります。記事のシステムと比較して、採用の妥当性を検討してみました。

## multi-agent-shogunシステムの概要

記事で紹介されている**multi-agent-shogun**システムの構成は次の通りです。

| 要素 | 内容 |
|------|------|
| 階層構造 | 将軍1名・家老1名・足軽8名（計10エージェント） |
| 通信方式 | YAMLファイルベース + tmux send-keys イベント駆動 |
| 実行環境 | WSL2 + tmux で9つのClaude Codeセッション並列管理 |
| コスト | Claude Max $100〜200/月で10エージェント運用 |

「違反は切腹」ルールとは、AIが自発的に生成した「最小権限の原則」（他の足軽の担当を奪うことを禁止）のことです。

## Claude Codeのスキル実行はシングルエージェント

ここで重要な気づきがありました。

**スキルを実行しているとき、マルチエージェントになっているのか？**

答えは**No**。

```text
現在のClaude Code動作:

User → Claude Code (1セッション)
           ↓
      スキル呼び出し（/steering等）
           ↓
      SKILL.mdがプロンプトに追加される
           ↓
      同じセッション内で処理継続
```

スキルは「役割を切り替える」だけで、物理的には**1つのClaude Codeセッション**が順次処理しています。25個のエージェント定義があっても、それは「定義」であって「並列実行」ではありません。

## multi-agent-shogunの仕組み

記事システムは物理的に複数のClaude Codeを起動しています。

```text
┌─────────────────────────────────────────────────────────┐
│ tmux session: multiagent                                │
├─────────────────────────────────────────────────────────┤
│ Window 0: shogun     │ Window 1: karo    │ Window 2    │
│ ┌─────────────────┐  │ ┌───────────────┐ │ ashigaru    │
│ │ claude          │  │ │ claude        │ │ ┌──┬──┬──┬──┐
│ │ (将軍セッション) │  │ │ (家老セッション)│ │ │1 │2 │3 │4 │
│ └─────────────────┘  │ └───────────────┘ │ ├──┼──┼──┼──┤
│                      │                   │ │5 │6 │7 │8 │
│                      │                   │ └──┴──┴──┴──┘
└─────────────────────────────────────────────────────────┘
```

### 起動と通信の流れ

1. 将軍がタスクをYAMLに書く（`queue/tasks/karo.yaml`）
2. `tmux send-keys` で家老を起こす
3. 家老がYAMLを読み、足軽用に分解
4. `tmux send-keys` で各足軽を起こす
5. 足軽が完了したらステータスをYAMLに書く
6. 家老が完了を検知、将軍に報告

### イベント駆動のメリット

ポーリングではなく、必要時のみ通信する方式です。待機中のAPI消費がゼロになります。

「9体 × 5秒ポーリング = 108回/分」の破産リスクを回避できます。

## MUSUBIの現状（定義 vs 実運用）

自分のプロジェクトで使っているMUSUBIフレームワークを振り返ると、次の通りです。

| 観点 | MUSUBIの状態 | 備考 |
|------|-------------|------|
| 役割分担 | 定義のみ | 27スキル定義あり、協調動作なし |
| ルール強制 | 定義のみ | 憲法9条定義あり、自動検証なし |
| タスク分解 | 定義のみ | @orchestrator未使用 |
| 並列実行 | なし | シングルセッションのみ |
| 進行状況可視化 | なし | 監視機構なし |

**「定義がある」と「実際に機能している」は別物**でした。

## マルチエージェント開発に必要な仕掛け

Claude Codeで真のマルチエージェント開発を実現するには、次の仕掛けが必要です。

| 要素 | 必要な仕掛け |
|------|-------------|
| 並列実行 | tmux等で複数セッション起動 |
| エージェント間通信 | ファイルベース（YAML等）またはMCP |
| タスク分配 | オーケストレーター（将軍/家老相当） |
| 進行状況監視 | ダッシュボード/ステータスファイル |
| 完了検知・結果集約 | ファイル監視 + 集約ロジック |

multi-agent-shogunが提供しているのが、まさにこれらの「仕掛け」です。

## 結論

MUSUBIは「何をするか」（27スキル定義）を持っていますが、「どう協調させるか」の実装がありません。

記事システムは逆に「どう協調させるか」（tmux + YAML通信）を持っています。

両者は**補完関係**にあります。

### 採用オプション

- A. 記事システムをベースに、MUSUBIの定義を活用 - 将軍/家老/足軽の実行基盤 + 27スキルの専門性
- B. MUSUBIにtmux並列実行レイヤーを追加 - 既存システムを拡張
- C. 用途別に使い分け - 大規模タスクは記事システム、通常作業はMUSUBI

### 前提条件

| 項目 | 備考 |
|------|------|
| WSL2環境 | Windows環境での動作に必要 |
| tmux | `apt install tmux` |
| Claude Max契約 | 並列実行にはAPI容量が必要 |

## 参考

- [Claude Codeで「AI部下10人」を作ったら〜](https://zenn.dev/shio_shoppaize/articles/5fee11d03a11a1)
- [MUSUBI - Specification Driven Development](https://www.npmjs.com/package/musubi-sdd)
